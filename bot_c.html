<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Панель управления</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style> /* (стили как у вас) */ </style>
</head>
<body>
<div class="app-container" id="app">
  <!-- (ваша разметка UI — без изменений) -->
  <div id="diagnostic" class="diag" aria-live="polite">
    <strong>Диагностика WebApp/initData:</strong>
    <pre id="diag-content">проверка...</pre>
  </div>
</div>

<script>
  // ==== ВАЖНО: замените этот URL на ваш публичный бекенд (ngrok или домен) ====
  // Пример: const API_HOST = "https://0570da370db6.ngrok-free.app";
  // НЕ оставляйте пустым, если бек работает не на том же origin что фронт (github.io).
  const API_HOST = "https://YOUR_BACKEND_URL_HERE";

  // helper: парсер initData из хэша (fallback), и resolve
  function getInitDataFallbackFromHash() {
    try {
      if (!window.location.hash) return null;
      const h = window.location.hash.replace(/^#/, '');
      const params = new URLSearchParams(h.replace(/\?/g, '&'));
      const raw = params.get('tgWebAppData') || params.get('tgWebAppInitData') || null;
      if (raw) return decodeURIComponent(raw);
      if (h.startsWith('tgWebAppData=')) return decodeURIComponent(h.slice(h.indexOf('=')+1));
      return null;
    } catch (e) { console.error(e); return null; }
  }
  function resolveInitData() {
    try {
      if (window.Telegram && window.Telegram.WebApp) {
        const d = window.Telegram.WebApp.initData || window.Telegram.WebApp.initDataUnsafe?.data || null;
        if (d) return d;
      }
    } catch (e) {}
    return getInitDataFallbackFromHash();
  }

  // Улучшённый fetch для баланса с логированием ошибок
  async function fetchAndShowBalance() {
    setResult("Загрузка баланса...");
    const initData = resolveInitData();
    if (!initData) {
      setResult("Ошибка: Не удалось получить данные Telegram для аутентификации.");
      return;
    }

    const url = `${API_HOST.replace(/\/$/, "")}/get_balance`;
    console.log("GET_BALANCE ->", url);
    try {
      const resp = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "ngrok-skip-browser-warning": "true"
        },
        body: JSON.stringify({ initData: initData, pair: params.pair })
      });

      // подробно логируем ответ
      const text = await resp.text();
      let data = null;
      try { data = JSON.parse(text); } catch(e) { data = null; }

      if (!resp.ok) {
        console.error("get_balance HTTP error", resp.status, text);
        setResult(`Ошибка сервера (баланс): HTTP ${resp.status}\n${text}`);
        return;
      }

      if (data && data.error) {
        console.warn("get_balance returned error:", data.error);
        setResult(`Ошибка: ${data.error}`);
        return;
      }

      if (data) {
        setResult(`Баланс:\n${data.base}: ${data.base_balance}\n${data.quote}: ${data.quote_balance}`);
      } else {
        setResult("Ошибка: некорректный ответ сервера (баланс). См. консоль.");
        console.log("get_balance raw response:", text);
      }
    } catch (err) {
      console.error("Network or CORS error when calling get_balance:", err);
      setResult("Ошибка соединения с сервером (баланс). Проверьте API_HOST и доступность бэкенда.");
    }
  }

  // подключение к WebSocket с использованием API_HOST
  function wsUrlFromApiHost(apiHost) {
    if (!apiHost) apiHost = window.location.origin;
    if (apiHost.startsWith("https://")) return apiHost.replace(/^https:\/\//, "wss://");
    if (apiHost.startsWith("http://")) return apiHost.replace(/^http:\/\//, "ws://");
    return (location.protocol === "https:" ? "wss://" : "ws://") + apiHost;
  }
  function connectWS() {
    if (ws) ws.close();
    const base_ws = wsUrlFromApiHost(API_HOST || window.location.origin);
    const ws_url = `${base_ws.replace(/\/$/, "")}/ws`;
    console.log("Connecting WS to", ws_url);
    ws = new WebSocket(ws_url);
    ws.onopen = () => console.log("WebSocket connected");
    ws.onmessage = (event) => setResult(event.data);
    ws.onclose = () => { console.log("WebSocket closed"); setResult("WebSocket closed"); };
    ws.onerror = (err) => { console.error('WebSocket Error: ', err); setResult("Ошибка WebSocket"); };
  }

  // остальные функции UI (setResult, startTrade, и т.д.) — используем resolveInitData() аналогично
  function setResult(text) {
    const block = document.getElementById("result-block");
    if (!block) return;
    block.innerHTML = "";
    if (text) text.split("\n").forEach(line => {
      if (line.trim().length>0) {
        const d = document.createElement("div"); d.className="result-line"; d.textContent=line;
        block.appendChild(d);
      }
    });
  }

  async function startTrade() {
    const initData = resolveInitData();
    if (!initData) { setResult("Ошибка: Нет initData"); return; }
    const url = `${API_HOST.replace(/\/$/, "")}/start_trade`;
    console.log("START_TRADE ->", url);
    try {
      const resp = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json", "ngrok-skip-browser-warning": "true" },
        body: JSON.stringify(Object.assign({}, params, { initData: initData }))
      });
      const text = await resp.text();
      try {
        const data = JSON.parse(text);
        if (data.error) { setResult(`Ошибка: ${data.error}`); console.warn("start_trade error", data); }
        else setResult("Запуск торговой операции: OK");
      } catch (e) {
        setResult("Некорректный ответ сервера при старте. См. консоль.");
        console.log("start_trade raw:", text);
      }
    } catch (err) {
      console.error("Network error start_trade:", err);
      setResult("Ошибка соединения с сервером (start_trade).");
    }
  }

  // Diagnostics и init flow — если initData есть, подключаемся
  document.addEventListener("DOMContentLoaded", () => {
    try { if (window.Telegram && window.Telegram.WebApp && typeof Telegram.WebApp.ready === 'function') Telegram.WebApp.ready(); } catch(e){}
    const resolved = resolveInitData();
    const diagObj = {
      ts: new Date().toISOString(),
      location: window.location.href,
      tgObj: !!(window.Telegram && window.Telegram.WebApp),
      initDataFromHash: !!getInitDataFallbackFromHash(),
      initDataResolved: !!resolved
    };
    document.getElementById('diag-content').textContent = JSON.stringify(diagObj, null, 2);
    console.log("Diag:", diagObj);
    if (resolved) { fetchAndShowBalance(); connectWS(); return; }
    // wait briefly for possible late injection
    let tries = 0; const max = 12;
    const t = setInterval(() => {
      tries++;
      const now = resolveInitData();
      if (now) { clearInterval(t); fetchAndShowBalance(); connectWS(); return; }
      if (tries>=max) { clearInterval(t); console.warn("initData not received"); }
    }, 250);
  });
</script>
</body>
</html>
